1/ tRPC: 
- TypeScript-first framework for building end-to-end type-safe APIs.

2/ Routers:
- Responsible for mapping incoming requests to their respective handlers, which are determined by the URL of the request.

3/ Route:
- A designated path or pattern in a web application.
- Each route is associated with an action or a set of actions. These actions determine what the application should do when a user accesses a particular path.

4/ Endpoint:
- Endpoints function a little like phone numbers: just as a user dials a phone number to reach a certain person or business, API clients (the software making an API call) provide an endpoint URL to reach a specific resource. An endpoint URL provides the location of a resource on an API server and helps connect the API client with the resource it is requesting. It essentially tells the server, “the resource that I need is located here.”

5/ trpc/client.tsx is the entrypoint when consuming your tRPC API from client components.

6/ typeof window !== "undefined" --> meaning: "Am I running on the browser?"
7/ typeof window === "undefined" --> meaning: "Am I running on the server?"

8/ getUrl() function in client.tsx:
tRPC needs a consistent endpoint to send its queries and mutations. Without this function, your code would break in one of two scenarios:
- Server-Side Rendering (SSR): If your layout.tsx tries to fetch data before the page reaches the user, it needs an absolute URL (starting with http) because there is no browser "origin" yet.
- Deployment: If you hardcoded localhost:3000, your app would work on your laptop but fail immediately once you deployed it to the internet because the production server would try to "call itself" at a local address that doesn't exist in the cloud.

9/ - selectedScrollSnap(): returns the index of the snap point the carousel is currently resting on
- scrollSnapList(): returns an array of the "snap points" (the exact positions where the carousel stops)

10/ fetching and playing video
- each user will have one studio: getOne method of studioRouter receives an "id" parameter and userId (by accessing ctx context) => find the video in the videos table that has the "id" (primary key) that matches the "id" passed when getOne is called with the correct user - userId (foreign key in videos table) matches the userId of ctx.user.
- use getMany method of studioRouter to get all videos for using in videoSection to show general information of studio.
    + map through videos array to get the id of video => <Link href={`/studio/videos/${video.id}`} >
    => this video.id is the videoId (dynamic segment) that extracted by awaiting params
    => videoId (params) will have the value first when getMany is called and map the return videos arrays
    => when getOne is called, pass this {id: videoId}