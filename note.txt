* Dependencies:
A/ Clerk: authentication and usage management service

B/ Neon: serverless Postgres database platform with branching feature

C/ Drizzle: handle the database interactions in TypeScript and JavaScript applications while maintaining strong type safety and performance
=> Neon = Database (WHERE data lives). It's a Postgres database hosting service
   Drizzle = ORM (HOW you talk to data). It's a TypeScript library for writing database queries

D/ tRPC (TypeScript Remote Procedure Call): a framework for building end-to-end type-safe APIs in TypeScript. It eliminates the need for manually defining API routes, request validation, and client-side fetching logic. Instead, your frontend can call backend functions as if they were local functions.

E/ Upstash: serverless data platform => used for 
    - Rate limiting APIs
    - Session storage
    - Caching expensive queries
    - Real-time counters/analytics
    - Edge/serverless applications
    - Temporary data storage
+ Rate limiting APIs: controls traffic by restricting the number of requests a client can make within a specific timeframe, preventing server overload, abuse, and ensuring system stability.

F/ Mux: video infrastructure platform that provides APIs for video streaming.

G/ uploadthing: file upload service

H/ Svix: webhook infrastructure platform that handles sending and managing webhooks for the application.

1/ tRPC: 
- TypeScript-first framework for building end-to-end type-safe APIs.

2/ Routers:
- Responsible for mapping incoming requests to their respective handlers, which are determined by the URL of the request.

3/ Route:
- A designated path or pattern in a web application.
- Each route is associated with an action or a set of actions. These actions determine what the application should do when a user accesses a particular path.

4/ Endpoint:
- Endpoints function a little like phone numbers: just as a user dials a phone number to reach a certain person or business, API clients (the software making an API call) provide an endpoint URL to reach a specific resource. An endpoint URL provides the location of a resource on an API server and helps connect the API client with the resource it is requesting. It essentially tells the server, “the resource that I need is located here.”

5/ trpc/client.tsx is the entrypoint when consuming your tRPC API from client components.

6/ typeof window !== "undefined" --> meaning: "Am I running on the browser?"
7/ typeof window === "undefined" --> meaning: "Am I running on the server?"

8/ getUrl() function in client.tsx:
tRPC needs a consistent endpoint to send its queries and mutations. Without this function, your code would break in one of two scenarios:
- Server-Side Rendering (SSR): If your layout.tsx tries to fetch data before the page reaches the user, it needs an absolute URL (starting with http) because there is no browser "origin" yet.
- Deployment: If you hardcoded localhost:3000, your app would work on your laptop but fail immediately once you deployed it to the internet because the production server would try to "call itself" at a local address that doesn't exist in the cloud.

9/ - selectedScrollSnap(): returns the index of the snap point the carousel is currently resting on
- scrollSnapList(): returns an array of the "snap points" (the exact positions where the carousel stops)

10/ fetching and playing video
- each user will have one studio: getOne method of studioRouter receives an "id" parameter and userId (by accessing ctx context) => find the video in the videos table that has the "id" (primary key) that matches the "id" passed when getOne is called with the correct user - userId (foreign key in videos table) matches the userId of ctx.user.
- use getMany method of studioRouter to get all videos for using in videoSection to show general information of studio.
    + map through videos array to get the id of video => <Link href={`/studio/videos/${video.id}`} >
    => this video.id is the videoId (dynamic segment) that extracted by awaiting params
    => videoId (params) will have the value first when getMany is called and map the return videos arrays
    => when getOne is called, pass this {id: videoId}

11/ {control, handleSubmit} = useForm()

12/ trpc.useUtils(): React hook that gives you access to utility functions for managing tRPC queries and mutations.

13/ webhooks: event-based APIs, user-defined HTTP callback that enables real-time communication between applications by instantly (automatically) transmitting data when a specific event occurs
* Webhooks and APIs:
A/ APIs:
- When a client API requests data from a server API, it’s calling to see if a certain event has occurred—in other words, whether the server’s data has changed in a way that might be useful to the client. In this process (known as "polling"), the client sends an HTTP request at regular intervals until the server’s API sends the relevant data, which is sometimes called the payload. 
- The client app doesn’t know the state of the server app, so it polls the server’s API for an update—calling over and over until the specific event occurs—but the server will only send the requested data once that information is available. The client app has to keep asking for the update and wait until the relevant event happens.

B/ Webhooks:
- To set up a webhook, the client gives a unique URL to the server API and specifies which event it wants to know about. Once the webhook is set up, the client no longer needs to poll the server; the server will automatically send the relevant payload to the client’s webhook URL when the specified event occurs. 
- Webhooks are often referred to as reverse APIs or push APIs, because they put the responsibility of communication on the server, rather than the client. Instead of the client sending HTTP requests—asking for data until the server responds—the server sends the client a single HTTP POST request as soon as the data is available. Despite their nicknames, webhooks are not APIs; they work together. An application must have an API to use a webhook.
- The name webhook is a simple combination of web, referring to its HTTP-based communication, and the hooking programming function that allows apps to intercept calls or other events that might be of interest. Webhooks hook the event that occurs on the server app, and prompt the server to send the payload to the client via the web.
